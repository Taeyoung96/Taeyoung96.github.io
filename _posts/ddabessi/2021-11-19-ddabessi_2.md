---
title : "[Modern C++] 따베씨++ Chapter 2 정리"
category :
    - ddabessi
tag :
    - modern-cpp
    - 따베씨++
toc : true
toc_sticky: true
comments: true
---  

따베씨++ Chapter 2을 듣고 정리해보자!  

Modern C++을 복습하기 위해 인프런에서 홍정모 교수님의 [따라하며 배우는 C++](https://www.inflearn.com/course/following-c-plus)를 정리해보자.  
C++을 처음 배우는 사람이 대상이다보니, 초반부는 조금 쉽다고 느껴진다.  
하지만 기초를 탄탄히 한다는 마음으로 정리를 해보았다.     

쳅터 1은 **C++의 기초적인 사용법**이라는 이름으로 되어있다.  

이 포스팅에서는 강의에서 나눈 쳅터와 동일하게 쳅터를 나누었다.  

## 1. 기본 자료형 소개  

[Chapter 1](https://taeyoung96.github.io/ddabessi/ddabessi_1/)에서는 변수를 선언할 때 `int` 자료형을 사용했다.  

이번 쳅터에서는 C++에 있는 다양한 자료형에 대해 배우고, 초기화 하는 방법을 배웠다.  

<p align="center"><img src="https://user-images.githubusercontent.com/41863759/142603872-d309ac75-4a3d-413e-a4a7-72321969972d.png" width = "600" ></p>  

자료형은 Data Type에 따라서 차지하는 bit수에 따라서도 다양하게 존재한다.  
**참고로 1byte = 8bit이다!**  

변수가 선언이 되면 메모리의 어떤 공간에 변수가 들어갈 공간이 생기는데,  
이 때 자료형마다 차지하는 공간의 크기가 다르다.  

주소 값을 보기 위해 아래와 같은 코드를 사용해보자.  

```cpp
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    int i = -1;
    cout << (uintptr_t)static_cast<void*>(&i) << endl;  // #1
    cout << static_cast<void*>(&i) << endl;             // #2
    cout << &i << endl;                                 // #3

    return 0;
}
```

출력 결과는 다음과 같다.  
```bash
16119588    // #1 : 주소 값을 10진수로 출력  
00F5F724    // #2 : 주소 값을 16진수로 출력
00F5F724    // #3 : 주소 값을 16진수로 출력
```

`static_cast`는 형변환을 할 때 사용하고, `void*` 같은 경우는 자료형을 몰라도 주소 값을 출력할 때 사용한다.  
`(uintptr_t)`의 경우 자세한 건 조금 더 알아봐야 하지만, 주소값이 10진수로 출력되는 것을 확인했다.  

bool형의 초기화 방법은 다음과 같다.  
bool형은 내부적으로 숫자로 저장된다.  
```cpp
// bool형 초기화
bool bValue = true;
cout << (bValue ? 1 : -1) << endl;      // 삼항 연산자 사용 :    1 출력
cout << bValue << endl;			// bool형도 내부적으로 숫자로 저장 :   1 출력
```

문자(char형)의 초기화 방법은 다음과 같다.  
문자도 내부적으로 숫자로 저장된다.  

```cpp
// 문자도 결국 숫자로 저장한다. 
char chValue = 65;                      // 아스키 코드 
cout << chValue << endl;		// A를 출력
```

Float형과 Double형을 이용해서 실수를 표현할 수 있다. Float형이 Double형보다 더 정밀하게 수를 표현할 수 있다. 이 두 자료형의 차이점에 대해서는 다음 쳅터에서 조금 더 자세히 다룬다고 하셨다.  

```cpp
// float형 double형 초기화
float fValue = 3.141592f;
double dValue = 3.141592;

cout << fValue << endl;     // 3.14159 출력
cout << dValue << endl;     // 3.14159 출력
```  

위 코드의 경우 cout이 자동적으로 소수 5번째 자리까지만 출력하도록 되어있기 때문에 같은 수가 출력이 된다.  

또한 Modern C++의 경우 Datatype을 자동적으로 잡아주는 `auto` 자료형이 추가되었다.  

```cpp
// Modern C++에 생긴 자료형 - 자동으로 자료형을 결정
auto aValue = 3.141592f;
auto aValue2 = 3.141592;  

// sizeof()는 Datatype, 변수 둘다 넣어줄 수 있다.
cout << sizeof(aValue) << endl;     // 4 출력	
cout << sizeof(aValue2) << endl;    // 8 출력
cout << sizeof(double) << endl;    // 8 출력
```

참고로 sizeof() 함수는 메모리 공간에 차지하는 Byte 수를 알려준다.  
위 주석대로 변수뿐만 아니라 자료형도 Input으로 넣어줄 수 있다.  

C++에서는 초기화 방법이 크게 3가지가 있다.  

```cpp
// C++ 초기화 방법 1 : Copy initialization
int a = 123;

// C++ 초기화 방법 2 : Dircet initialization
int b(224);

// C++ 초기화 방법 3 : Uniform initialization
int c{ 244 };
```

Copy initialization은 우리가 흔히 초기화할 때 사용하는 방법이고,  
Direct initialization과 Uniform initalziation은 객체 지향을 배우고 그것을 초기화 할 때 종종 사용한다.  

Uniform initialization의 방법이 Direct initialization보다 조금 더 엄격하다.  
예를 들어 Datatype을 맞춰주지 않고 초기화를 할 경우 Direct 초기화 방법은 Warning이 뜨지만, Uniform 초기화 방법은 Error가 뜬다.  

**그렇다면 변수 선언은 언제 하는것이 좋을까?**  

최근에는 변수 사용 직전에 선언을 하는 것이 최근 Trend이다.  

그 이유는 다음과 같다.  
- 디버깅을 하기 편하기 때문  
- 리팩토링이 편하기 때문  

물론 개발하는 팀이나 스타일 가이드가 있을 경우 그를 따르는 것이 좋다.  
